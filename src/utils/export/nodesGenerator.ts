/**
 * Generate Kedro nodes.py from pipeline nodes
 */

import type { KedroNode, KedroDataset, KedroConnection } from '../../types/kedro';
import {
  toSnakeCase,
  formatFunctionParams,
  formatDocstringParams,
  indentCode,
} from './helpers';

/**
 * Generate nodes.py content
 */
export function generateNodes(
  nodes: KedroNode[],
  connections: KedroConnection[],
  datasets: Record<string, KedroDataset>,
  pipelineName: string
): string {
  const header = `"""
Node functions for ${pipelineName} pipeline.
Generated by Kedro Pipeline Builder.

This module contains the data processing and transformation functions (nodes)
that make up your Kedro pipeline. Each function should be a pure function that
takes inputs and returns outputs without side effects.
"""

from typing import Dict, Any, Tuple
import pandas as pd
import logging

logger = logging.getLogger(__name__)

`;

  if (nodes.length === 0) {
    return header + '# No nodes defined\n';
  }

  const functions = nodes.map((node) =>
    generateNodeFunction(node, connections, datasets)
  );

  return header + functions.join('\n\n\n');
}

/**
 * Generate a single node function
 */
function generateNodeFunction(
  node: KedroNode,
  connections: KedroConnection[],
  datasets: Record<string, KedroDataset>
): string {
  const funcName = toSnakeCase(node.name);
  const inputs = getNodeInputs(node, connections, datasets);
  const outputs = getNodeOutputs(node, connections, datasets);

  // Use user's custom code if provided
  if (node.functionCode && node.functionCode.trim()) {
    return generateCustomFunction(funcName, inputs, outputs, node);
  }

  // Generate template function
  return generateTemplateFunction(funcName, inputs, outputs, node);
}

/**
 * Generate function using user's custom code
 */
function generateCustomFunction(
  funcName: string,
  inputs: string[],
  outputs: string[],
  node: KedroNode
): string {
  const params = formatFunctionParams(inputs);
  const paramDocs = formatDocstringParams(inputs);
  const returnType = getReturnType(outputs);

  const userCode = node.functionCode!.trim();
  const indentedCode = indentCode(userCode, 4);

  return `def ${funcName}(${params}) -> ${returnType}:
    """
    ${node.name || 'Custom function'}.

    Args:
${paramDocs}

    Returns:
        ${getReturnDescription(outputs)}
    """
${indentedCode}`;
}

/**
 * Generate template function with TODO placeholder
 */
function generateTemplateFunction(
  funcName: string,
  inputs: string[],
  outputs: string[],
  node: KedroNode
): string {
  const params = formatFunctionParams(inputs);
  const paramDocs = formatDocstringParams(inputs);
  const returnType = getReturnType(outputs);
  const functionBody = generatePlaceholderBody(inputs, outputs);

  return `def ${funcName}(${params}) -> ${returnType}:
    """
    ${node.name || funcName}.

    Args:
${paramDocs}

    Returns:
        ${getReturnDescription(outputs)}
    """
    # TODO: Implement your ${node.type || 'processing'} logic here
    logger.info("Running ${node.name || funcName}...")
${functionBody}`;
}

/**
 * Generate placeholder function body based on inputs/outputs
 */
function generatePlaceholderBody(inputs: string[], outputs: string[]): string {
  if (outputs.length === 0) {
    // No outputs - just pass
    return '    \n    pass';
  } else if (outputs.length === 1) {
    // Single output
    const outputVar = toSnakeCase(outputs[0]);
    const inputRef =
      inputs.length > 0 ? `${toSnakeCase(inputs[0])}.copy()` : 'pd.DataFrame()';
    return `
    # Replace with your actual processing logic
    ${outputVar} = ${inputRef}

    return ${outputVar}`;
  } else {
    // Multiple outputs - return tuple
    const outputVars = outputs.map((out) => toSnakeCase(out));
    const assignments = outputs.map((out, idx) => {
      const outputVar = toSnakeCase(out);
      const inputRef =
        inputs.length > idx
          ? `${toSnakeCase(inputs[idx])}.copy()`
          : 'pd.DataFrame()';
      return `    ${outputVar} = ${inputRef}  # Replace with actual processing`;
    });

    return `
${assignments.join('\n')}

    return (${outputVars.join(', ')})`;
  }
}

/**
 * Get return type hint based on number of outputs
 */
function getReturnType(outputs: string[]): string {
  if (outputs.length === 0) return 'None';
  if (outputs.length === 1) return 'pd.DataFrame';
  return `Tuple[${outputs.map(() => 'pd.DataFrame').join(', ')}]`;
}

/**
 * Get return description for docstring
 */
function getReturnDescription(outputs: string[]): string {
  if (outputs.length === 0) return 'None';
  if (outputs.length === 1) return `Processed ${outputs[0]}`;
  return `Tuple of (${outputs.join(', ')})`;
}

/**
 * Get input datasets for a node
 */
function getNodeInputs(
  node: KedroNode,
  connections: KedroConnection[],
  datasets: Record<string, KedroDataset>
): string[] {
  const inputs: string[] = [];

  connections.forEach((conn) => {
    // Find connections where dataset -> node
    if (conn.target === node.id && conn.source.startsWith('dataset-')) {
      const dataset = datasets[conn.source];
      if (dataset) {
        inputs.push(dataset.name);
      }
    }
  });

  return inputs;
}

/**
 * Get output datasets for a node
 */
function getNodeOutputs(
  node: KedroNode,
  connections: KedroConnection[],
  datasets: Record<string, KedroDataset>
): string[] {
  const outputs: string[] = [];

  connections.forEach((conn) => {
    // Find connections where node -> dataset
    if (conn.source === node.id && conn.target.startsWith('dataset-')) {
      const dataset = datasets[conn.target];
      if (dataset) {
        outputs.push(dataset.name);
      }
    }
  });

  return outputs;
}
