/**
 * @vitest-environment node
 */
import { describe, it, expect } from 'vitest';
import { generateNodes } from './nodesGenerator';
import { KedroNode, KedroDataset, KedroConnection } from '../../types/kedro';

describe('nodesGenerator', () => {
  describe('generateNodes', () => {
    it('should generate header with empty nodes', () => {
      const result = generateNodes([], [], {}, 'test_pipeline');

      expect(result).toContain('Node functions for test_pipeline pipeline');
      expect(result).toContain('Generated by Kedro Pipeline Builder');
      expect(result).toContain('import pandas as pd');
      expect(result).toContain('import logging');
      expect(result).toContain('# No nodes defined');
    });

    it('should generate simple node with no inputs or outputs', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'init_node',
        type: 'custom',
        inputs: [],
        outputs: [],
        position: { x: 0, y: 0 },
      };

      const result = generateNodes([node], [], {}, 'test');

      expect(result).toContain('def init_node() -> None:');
      expect(result).toContain('"""init_node."""');
      expect(result).toContain('pass');
    });

    it('should generate node with single input and single output', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'process_data',
        type: 'data_processing',
        inputs: ['raw_data'],
        outputs: ['processed_data'],
        position: { x: 0, y: 0 },
      };

      const dataset1: KedroDataset = {
        id: 'dataset-1',
        name: 'raw_data',
        type: 'csv',
        position: { x: 0, y: 0 },
      };

      const dataset2: KedroDataset = {
        id: 'dataset-2',
        name: 'processed_data',
        type: 'parquet',
        position: { x: 0, y: 0 },
      };

      const connections: KedroConnection[] = [
        {
          id: 'conn-1',
          source: 'dataset-1',
          target: 'node-1',
          sourceHandle: 'out',
          targetHandle: 'in',
        },
        {
          id: 'conn-2',
          source: 'node-1',
          target: 'dataset-2',
          sourceHandle: 'out',
          targetHandle: 'in',
        },
      ];

      const datasets = {
        'dataset-1': dataset1,
        'dataset-2': dataset2,
      };

      const result = generateNodes([node], connections, datasets, 'test');

      expect(result).toContain('def process_data(raw_data: pd.DataFrame) -> pd.DataFrame:');
      expect(result).toContain('Args:');
      expect(result).toContain('raw_data: Input raw_data');
      expect(result).toContain('Returns:');
      expect(result).toContain('Processed processed_data');
      expect(result).toContain('# TODO: Implement your data_processing logic here');
      expect(result).toContain('logger.info("Running process_data...")');
    });

    it('should generate node with multiple inputs and multiple outputs', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'merge_data',
        type: 'data_processing',
        inputs: ['data1', 'data2'],
        outputs: ['merged', 'stats'],
        position: { x: 0, y: 0 },
      };

      const datasets = {
        'dataset-1': { id: 'dataset-1', name: 'data1', type: 'csv', position: { x: 0, y: 0 } } as KedroDataset,
        'dataset-2': { id: 'dataset-2', name: 'data2', type: 'csv', position: { x: 0, y: 0 } } as KedroDataset,
        'dataset-3': { id: 'dataset-3', name: 'merged', type: 'parquet', position: { x: 0, y: 0 } } as KedroDataset,
        'dataset-4': { id: 'dataset-4', name: 'stats', type: 'json', position: { x: 0, y: 0 } } as KedroDataset,
      };

      const connections: KedroConnection[] = [
        { id: '1', source: 'dataset-1', target: 'node-1', sourceHandle: 'out', targetHandle: 'in' },
        { id: '2', source: 'dataset-2', target: 'node-1', sourceHandle: 'out', targetHandle: 'in' },
        { id: '3', source: 'node-1', target: 'dataset-3', sourceHandle: 'out', targetHandle: 'in' },
        { id: '4', source: 'node-1', target: 'dataset-4', sourceHandle: 'out', targetHandle: 'in' },
      ];

      const result = generateNodes([node], connections, datasets, 'test');

      expect(result).toContain('def merge_data(data1: pd.DataFrame, data2: pd.DataFrame) -> Tuple[pd.DataFrame, pd.DataFrame]:');
      expect(result).toContain('data1: Input data1');
      expect(result).toContain('data2: Input data2');
      expect(result).toContain('Tuple of (merged, stats)');
      expect(result).toContain('return (merged, stats)');
    });

    it('should generate node with custom function code', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'custom_func',
        type: 'custom',
        inputs: ['input_data'],
        outputs: ['output_data'],
        functionCode: `def custom_func(input_data: pd.DataFrame) -> pd.DataFrame:
    """Custom processing function."""
    return input_data.dropna()`,
        position: { x: 0, y: 0 },
      };

      const datasets = {
        'dataset-1': { id: 'dataset-1', name: 'input_data', type: 'csv', position: { x: 0, y: 0 } } as KedroDataset,
        'dataset-2': { id: 'dataset-2', name: 'output_data', type: 'parquet', position: { x: 0, y: 0 } } as KedroDataset,
      };

      const connections: KedroConnection[] = [
        { id: '1', source: 'dataset-1', target: 'node-1', sourceHandle: 'out', targetHandle: 'in' },
        { id: '2', source: 'node-1', target: 'dataset-2', sourceHandle: 'out', targetHandle: 'in' },
      ];

      const result = generateNodes([node], connections, datasets, 'test');

      expect(result).toContain('def custom_func(input_data: pd.DataFrame) -> pd.DataFrame:');
      expect(result).toContain('"""Custom processing function."""');
      expect(result).toContain('return input_data.dropna()');
      expect(result).not.toContain('# WARNING:');
    });

    it('should warn when custom function name does not match node name', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'expected_name',
        type: 'custom',
        inputs: [],
        outputs: [],
        functionCode: `def wrong_name() -> None:
    """Function with wrong name."""
    pass`,
        position: { x: 0, y: 0 },
      };

      const result = generateNodes([node], [], {}, 'test');

      expect(result).toContain('# WARNING: Function name "wrong_name" in your code does not match node name "expected_name"');
      expect(result).toContain('# The pipeline expects the function to be named "expected_name"');
      expect(result).toContain('def wrong_name() -> None:');
    });

    it('should wrap user code if no function definition provided', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'simple_node',
        type: 'data_processing',
        inputs: ['data'],
        outputs: ['result'],
        functionCode: `result = data.dropna()
return result`,
        position: { x: 0, y: 0 },
      };

      const datasets = {
        'dataset-1': { id: 'dataset-1', name: 'data', type: 'csv', position: { x: 0, y: 0 } } as KedroDataset,
        'dataset-2': { id: 'dataset-2', name: 'result', type: 'parquet', position: { x: 0, y: 0 } } as KedroDataset,
      };

      const connections: KedroConnection[] = [
        { id: '1', source: 'dataset-1', target: 'node-1', sourceHandle: 'out', targetHandle: 'in' },
        { id: '2', source: 'node-1', target: 'dataset-2', sourceHandle: 'out', targetHandle: 'in' },
      ];

      const result = generateNodes([node], connections, datasets, 'test');

      expect(result).toContain('def simple_node(data: pd.DataFrame) -> pd.DataFrame:');
      expect(result).toContain('    result = data.dropna()');
      expect(result).toContain('    return result');
    });

    it('should handle node with only inputs (no outputs)', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'sink_node',
        type: 'custom',
        inputs: ['data'],
        outputs: [],
        position: { x: 0, y: 0 },
      };

      const datasets = {
        'dataset-1': { id: 'dataset-1', name: 'data', type: 'csv', position: { x: 0, y: 0 } } as KedroDataset,
      };

      const connections: KedroConnection[] = [
        { id: '1', source: 'dataset-1', target: 'node-1', sourceHandle: 'out', targetHandle: 'in' },
      ];

      const result = generateNodes([node], connections, datasets, 'test');

      expect(result).toContain('def sink_node(data: pd.DataFrame) -> None:');
      expect(result).toContain('Args:');
      expect(result).toContain('data: Input data');
      expect(result).toContain('Returns:');
      expect(result).toContain('None');
      expect(result).toContain('pass');
    });

    it('should convert node name with spaces to snake_case', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'Process Sales Data',
        type: 'data_processing',
        inputs: [],
        outputs: [],
        position: { x: 0, y: 0 },
      };

      const result = generateNodes([node], [], {}, 'test');

      expect(result).toContain('def process_sales_data() -> None:');
      expect(result).toContain('"""Process Sales Data."""');
    });

    it('should convert node name with CamelCase to snake_case', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'ProcessSalesData',
        type: 'data_processing',
        inputs: [],
        outputs: [],
        position: { x: 0, y: 0 },
      };

      const result = generateNodes([node], [], {}, 'test');

      expect(result).toContain('def process_sales_data() -> None:');
    });

    it('should generate multiple node functions separated by blank lines', () => {
      const nodes: KedroNode[] = [
        {
          id: 'node-1',
          name: 'func1',
          type: 'custom',
          inputs: [],
          outputs: [],
          position: { x: 0, y: 0 },
        },
        {
          id: 'node-2',
          name: 'func2',
          type: 'custom',
          inputs: [],
          outputs: [],
          position: { x: 0, y: 0 },
        },
      ];

      const result = generateNodes(nodes, [], {}, 'test');

      expect(result).toContain('def func1() -> None:');
      expect(result).toContain('def func2() -> None:');
      // Should be separated by 3 newlines
      expect(result).toMatch(/def func1.*\n\n\n.*def func2/s);
    });

    it('should include node description in docstring if provided', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'load_data',
        type: 'data_ingestion',
        inputs: [],
        outputs: [],
        description: 'Load data from source',
        position: { x: 0, y: 0 },
      };

      const result = generateNodes([node], [], {}, 'test');

      // Node name is used in docstring
      expect(result).toContain('"""load_data."""');
    });

    it('should include logger.info statement in template functions', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'process',
        type: 'data_processing',
        inputs: ['data'],
        outputs: ['result'],
        position: { x: 0, y: 0 },
      };

      const datasets = {
        'dataset-1': { id: 'dataset-1', name: 'data', type: 'csv', position: { x: 0, y: 0 } } as KedroDataset,
        'dataset-2': { id: 'dataset-2', name: 'result', type: 'parquet', position: { x: 0, y: 0 } } as KedroDataset,
      };

      const connections: KedroConnection[] = [
        { id: '1', source: 'dataset-1', target: 'node-1', sourceHandle: 'out', targetHandle: 'in' },
        { id: '2', source: 'node-1', target: 'dataset-2', sourceHandle: 'out', targetHandle: 'in' },
      ];

      const result = generateNodes([node], connections, datasets, 'test');

      expect(result).toContain('logger.info("Running process...")');
    });

    it('should generate placeholder body with DataFrame operations', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'transform',
        type: 'data_processing',
        inputs: ['input'],
        outputs: ['output'],
        position: { x: 0, y: 0 },
      };

      const datasets = {
        'dataset-1': { id: 'dataset-1', name: 'input', type: 'csv', position: { x: 0, y: 0 } } as KedroDataset,
        'dataset-2': { id: 'dataset-2', name: 'output', type: 'parquet', position: { x: 0, y: 0 } } as KedroDataset,
      };

      const connections: KedroConnection[] = [
        { id: '1', source: 'dataset-1', target: 'node-1', sourceHandle: 'out', targetHandle: 'in' },
        { id: '2', source: 'node-1', target: 'dataset-2', sourceHandle: 'out', targetHandle: 'in' },
      ];

      const result = generateNodes([node], connections, datasets, 'test');

      expect(result).toContain('output = input.copy()');
      expect(result).toContain('return output');
    });

    it('should handle empty string function code as no custom code', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'func',
        type: 'custom',
        inputs: [],
        outputs: [],
        functionCode: '   ',  // Whitespace only
        position: { x: 0, y: 0 },
      };

      const result = generateNodes([node], [], {}, 'test');

      // Should generate template, not use custom code
      expect(result).toContain('def func() -> None:');
      expect(result).toContain('pass');
    });

    it('should handle connections that point to non-existent datasets gracefully', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'process',
        type: 'data_processing',
        inputs: [],
        outputs: [],
        position: { x: 0, y: 0 },
      };

      const connections: KedroConnection[] = [
        { id: '1', source: 'dataset-nonexistent', target: 'node-1', sourceHandle: 'out', targetHandle: 'in' },
      ];

      const result = generateNodes([node], connections, {}, 'test');

      // Should not throw, and function should have no inputs
      expect(result).toContain('def process() -> None:');
    });

    it('should handle complex pipeline with multiple nodes', () => {
      const nodes: KedroNode[] = [
        {
          id: 'node-1',
          name: 'load_data',
          type: 'data_ingestion',
          inputs: [],
          outputs: [],
          position: { x: 0, y: 0 },
        },
        {
          id: 'node-2',
          name: 'clean_data',
          type: 'data_processing',
          inputs: [],
          outputs: [],
          position: { x: 0, y: 0 },
        },
        {
          id: 'node-3',
          name: 'train_model',
          type: 'model_training',
          inputs: [],
          outputs: [],
          position: { x: 0, y: 0 },
        },
      ];

      const result = generateNodes(nodes, [], {}, 'ml_pipeline');

      expect(result).toContain('Node functions for ml_pipeline pipeline');
      expect(result).toContain('def load_data() -> None:');
      expect(result).toContain('def clean_data() -> None:');
      expect(result).toContain('def train_model() -> None:');
    });

    it('should preserve exact indentation from custom function code', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'custom',
        type: 'custom',
        inputs: [],
        outputs: [],
        functionCode: `def custom() -> None:
    """Custom function with complex indentation."""
    if True:
        for i in range(10):
            if i % 2 == 0:
                print(i)`,
        position: { x: 0, y: 0 },
      };

      const result = generateNodes([node], [], {}, 'test');

      expect(result).toContain('    if True:');
      expect(result).toContain('        for i in range(10):');
      expect(result).toContain('            if i % 2 == 0:');
      expect(result).toContain('                print(i)');
    });

    it('should include proper return type for multiple outputs', () => {
      const node: KedroNode = {
        id: 'node-1',
        name: 'split_data',
        type: 'data_processing',
        inputs: ['data'],
        outputs: ['train', 'test', 'validation'],
        position: { x: 0, y: 0 },
      };

      const datasets = {
        'dataset-1': { id: 'dataset-1', name: 'data', type: 'csv', position: { x: 0, y: 0 } } as KedroDataset,
        'dataset-2': { id: 'dataset-2', name: 'train', type: 'parquet', position: { x: 0, y: 0 } } as KedroDataset,
        'dataset-3': { id: 'dataset-3', name: 'test', type: 'parquet', position: { x: 0, y: 0 } } as KedroDataset,
        'dataset-4': { id: 'dataset-4', name: 'validation', type: 'parquet', position: { x: 0, y: 0 } } as KedroDataset,
      };

      const connections: KedroConnection[] = [
        { id: '1', source: 'dataset-1', target: 'node-1', sourceHandle: 'out', targetHandle: 'in' },
        { id: '2', source: 'node-1', target: 'dataset-2', sourceHandle: 'out', targetHandle: 'in' },
        { id: '3', source: 'node-1', target: 'dataset-3', sourceHandle: 'out', targetHandle: 'in' },
        { id: '4', source: 'node-1', target: 'dataset-4', sourceHandle: 'out', targetHandle: 'in' },
      ];

      const result = generateNodes([node], connections, datasets, 'test');

      expect(result).toContain('Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]');
      expect(result).toContain('return (train, test, validation)');
    });
  });
});
